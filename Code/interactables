class interactable {
  constructor(xpos, ypos, xvel, yvel, type) {
    this.xpos = xpos;
    this.ypos = ypos;
    this.xvel = xvel;
    this.yvel = yvel;
    this.type = type;
  }
  //getters
  get XPos() {
    return this.xpos;
  }
  get YPos() {
    return this.ypos;
  }
  get XVel() {
    return this.xvel;
  }
  get YVel() {
    return this.yvel;
  }
  get Type() {
    return this.type;
  }
  //setters
  set XPos(set) {
    this.xpos = set;
  }
  set YPos(set) {
    this.ypos = set;
  }
  set XVel(set) {
    this.xvel = set;
  }
  set YVel(set) {
    this.yvel = set;
  }
  //functions
  //gravity for Interactable
  gravity() {
    this.yvel += 0.2;
  }
  //tests if y position is above a certain value, if true it will call function 'fell' which deletes the object, it also increases value of stats.fallen if object is a fruit
  move() {
    this.XPos += this.XVel;
    this.YPos += this.YVel;
  }
  fell(i) {
    if (Interactable[i].Type == 6) {
      stats.score += 5;
      delete Interactable[i];
    } else {
      stats.fallen++;
      delete Interactable[i];
    }
  }
  static cut(i) {
    if (Interactable[i].Type == 6) {
      bomb.cutBomb(i);
    } else {
      fruit.cutFruit(i);
    }
  }
}
class fruit extends interactable {
  constructor(xpos, ypos, xvelocity, yvelocity, type) {
    super(xpos, ypos, xvelocity, yvelocity, type);
  }
  static cutFruit(i) {
    //raise score and play sound
    stats.score += 10;
    sounds.fruitSlice();
    //search for an empty spot in CutEffects array
    let j = 0;
    while (CutEffects[j] != undefined) j++;
    //creates instance
    CutEffects[j] = new cutEffects(Interactable[i].XPos, Interactable[i].YPos, Interactable[i].type);
    //deletes fruit
    delete Interactable[i];
  }
  static splatterAnimation() {}
}
class bomb extends interactable {
  constructor(xpos, ypos, xvelocity, yvelocity, type) {
    super(xpos, ypos, xvelocity, yvelocity, type);
  }
  static cutBomb(i) {
    //lower health and play sound
    stats.health--;
    sounds.bombSlice();
    //search for an empty spot in CutEffects array
    let j = 0;
    while (CutEffects[j] != undefined) j++;
    //creates instance
    CutEffects[j] = new cutEffects(Interactable[i].XPos, Interactable[i].YPos, 6);
    //deletes bomb
    delete Interactable[i];
  }
}
class cutEffects {
  constructor(xpos, ypos, type) {
    this.xpos = xpos;
    this.ypos = ypos;
    this.type = type;
    this.timer = 40;
  }
  //getters
  get XPos() {return this.xpos;}
  get YPos() {return this.ypos;}
  get Type() {return this.type;}
  get Timer() {return this.timer;}
  //setters
  set XPos(set) {this.xpos = set;}
  set YPos(set) {this.ypos = set;}
  set Timer(set) {this.timer = set;}
  static drawEffects() {
    for(let i = 0; i < CutEffects.length; i++) {if (CutEffects[i] != undefined) {switch(CutEffects[i].Type) {
      case 0:
        image(redSplat, CutEffects[i].XPos, CutEffects[i].YPos, 80, 80);
        break;
      case 1:
          image(yellowSplat, CutEffects[i].XPos, CutEffects[i].YPos, 80, 80);
          break;
      case 2:
        image(clearSplat, CutEffects[i].XPos, CutEffects[i].YPos, 80, 80);
        break;
      case 3:
        image(orangeSplat, CutEffects[i].XPos, CutEffects[i].YPos, 80, 80);
        break;
      case 4:
        image(yellowSplat, CutEffects[i].XPos, CutEffects[i].YPos, 80, 80);
        break;
      case 5:
        image(redSplat, CutEffects[i].XPos, CutEffects[i].YPos, 80, 80);
        break;
      case 6:
        image(explosion, CutEffects[i].XPos, CutEffects[i].YPos, 80, 80);
        break;
    }}}
  }
  static deleteEffect() {
    for (let i = 0; i < CutEffects.length; i++) {
      if (CutEffects[i] != undefined) {
        CutEffects[i].Timer--;
        if (CutEffects[i].Timer < 0) delete CutEffects[i];
      }
    }
  }
}
CutEffects = [];
Interactable = [];
function spawnFruit() {
  setTimeout(spawnFruit, 750);
  if(letSpawn) {
    i = 0;
    while (Interactable[i] != undefined) i++;
    assignedX = random(300, 700);
    posNeg = assignedX < 500 ? 1 : -1;
    Interactable[i] = new fruit(
      assignedX,
      720,
      random(-10, 10) * posNeg,
      -12 - random(0, 4),
      int(random(0, 5))
    );
  }
}
function spawnBomb() {
  bombTimer = stats.wave < 15 ? (17.5 - stats.wave) * 100 : 250;
  setTimeout(spawnBomb, bombTimer);
  if(letSpawn) {
    i = 0;
    while (Interactable[i] != undefined) i++;
    assignedX = random(300, 700);
    posNeg = assignedX < 500 ? 1 : -1;
    Interactable[i] = new bomb(
      assignedX,
      720,
      random(-3, 3) * posNeg,
      -12 - random(0, 4),
      6
    );
  }
}
function drawInteractable(i) {
  switch (Interactable[i].Type) {
    case 0:
      image(apple, Interactable[i].XPos, Interactable[i].YPos, 80, 80);
      break;
    case 1:
      image(banana, Interactable[i].XPos, Interactable[i].YPos, 80, 80);
      break;
    case 2:
      image(coconut, Interactable[i].XPos, Interactable[i].YPos, 80, 80);
      break;
    case 3:
      image(orange, Interactable[i].XPos, Interactable[i].YPos, 80, 80);
      break;
    case 4:
      image(pineapple, Interactable[i].XPos, Interactable[i].YPos, 80, 80);
      break;
    case 5:
      image(watermelon, Interactable[i].XPos, Interactable[i].YPos, 80, 80);
      break;
    default:
      image(bombImg, Interactable[i].XPos, Interactable[i].YPos, 80, 80);
      break;
  }
}
function effectInteractable() {
  for (let i = 0; i < Interactable.length; i++) {
    if (Interactable[i] != undefined) {
      Interactable[i].move();
      Interactable[i].gravity();
      drawInteractable(i);
      if (Interactable[i].YPos > 800) Interactable[i].fell(i);
    }
  }
}
function interactablesBounce() {
  for(let i = 0; i < Interactable.length; i++) {
    if (Interactable[i] != undefined) {
      if(Interactable[i].XPos > width - 80 || Interactable[i].XPos < 0) {
        Interactable[i].XVel *= -1;
      }
    }
  }
}
